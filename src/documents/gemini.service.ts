import { Injectable } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { GoogleGenAI } from '@google/genai';

@Injectable()
export class GeminiService {
  private genAI: GoogleGenAI;

  constructor(private configService: ConfigService) {
    const apiKey = this.configService.get<string>('GEMINI_API_KEY');
    if (!apiKey) {
      throw new Error('GEMINI_API_KEY is required in environment variables');
    }
    this.genAI = new GoogleGenAI({ apiKey });
  }

  async semanticChunking(
    text: string,
    maxChunkSize: number = 1000,
  ): Promise<string[]> {
    try {
      const prompt = this.buildChunkingPrompt(text, maxChunkSize);

      const response = await this.genAI.models.generateContent({
        model: 'gemini-2.5-flash',
        contents: prompt,
      });

      const responseText = response.text;

      // Parse the response to extract chunks array
      const chunks = this.parseChunksFromResponse(responseText);

      if (chunks.length === 0) {
        throw new Error('No chunks were generated by Gemini');
      }

      return chunks;
    } catch (error) {
      console.error('Error in Gemini semantic chunking:', error);
      throw error;
    }
  }

  private buildChunkingPrompt(text: string, maxChunkSize: number): string {
    return `You are a semantic text chunking expert. Your task is to divide the following text into logical, semantic chunks without losing meaning.

CRITICAL REQUIREMENTS:
1. Each chunk MUST be approximately ${maxChunkSize} characters or less
2. Split the text at natural semantic boundaries (paragraphs, topics, ideas)
3. Each chunk (except the first) MUST include the last 2 sentences from the previous chunk for context overlap
4. The chunks MUST be in the EXACT order as they appear in the original text
5. DO NOT modify, rephrase, or change ANY content - keep the original text EXACTLY as is
6. DO NOT add any explanations, comments, or metadata
7. Return ONLY a valid JSON array of strings, where each string is a chunk

OUTPUT FORMAT:
Return a JSON array like this:
["chunk 1 text here", "chunk 2 with overlap from chunk 1", "chunk 3 with overlap from chunk 2"]

TEXT TO CHUNK:
${text}

Remember: Return ONLY the JSON array, nothing else. Keep all text exactly as provided.`;
  }

  private parseChunksFromResponse(responseText: string): string[] {
    try {
      // Try to find JSON array in the response
      const jsonMatch = responseText.match(/\[[\s\S]*\]/);

      if (!jsonMatch) {
        console.error('No JSON array found in response:', responseText);
        throw new Error('Invalid response format from Gemini');
      }

      const jsonString = jsonMatch[0];
      const chunks = JSON.parse(jsonString);

      if (!Array.isArray(chunks)) {
        throw new Error('Response is not an array');
      }

      // Validate that all chunks are strings
      const validChunks = chunks.filter(
        (chunk) => typeof chunk === 'string' && chunk.trim().length > 0,
      );

      if (validChunks.length === 0) {
        throw new Error('No valid chunks found in response');
      }

      return validChunks;
    } catch (error) {
      console.error('Error parsing Gemini response:', error);
      console.error('Response text:', responseText);
      throw error;
    }
  }

  async formatSearchResults(
    userQuery: string,
    searchResults: any[],
  ): Promise<string> {
    try {
      console.log(
        `Formatting search results for query: "${userQuery.substring(0, 100)}..."`,
      );
      console.log(`Total search results: ${searchResults.length}`);

      // Pre-filter results based on user query context
      const filteredResults = await this.preFilterResults(
        userQuery,
        searchResults,
      );

      console.log(`Filtered results: ${filteredResults.length}`);

      const prompt = this.buildFormattingPrompt(userQuery, filteredResults);

      const response = await this.genAI.models.generateContent({
        model: 'gemini-2.5-flash',
        contents: prompt,
      });

      return response.text;
    } catch (error) {
      console.error('Error formatting search results with Gemini:', error);
      throw error;
    }
  }

  private async preFilterResults(
    userQuery: string,
    searchResults: any[],
  ): Promise<any[]> {
    // If there are few results, return all
    if (searchResults.length <= 3) {
      return searchResults;
    }

    try {
      // Build a prompt for relevance filtering
      const resultsForFiltering = searchResults
        .map((result, index) => {
          const text = result.fields?.text || '';
          return `[${index}] ${text.substring(0, 500)}...`; // First 500 chars for quick evaluation
        })
        .join('\n\n');

      const filterPrompt = `You are a relevance filter. Given a user question and search results, identify which results are RELEVANT.

USER QUESTION: ${userQuery}

SEARCH RESULTS:
${resultsForFiltering}

Return ONLY a JSON array of indices (numbers) for results that are relevant to the question.
Example: [0, 2, 4]

If ALL results are relevant, return all indices. If NONE are relevant, return an empty array [].

JSON array of relevant indices:`;

      const response = await this.genAI.models.generateContent({
        model: 'gemini-2.5-flash',
        contents: filterPrompt,
      });

      const responseText = response.text;
      const jsonMatch = responseText.match(/\[[\d,\s]*\]/);

      if (jsonMatch) {
        const relevantIndices: number[] = JSON.parse(jsonMatch[0]);
        console.log(`Relevant indices identified: [${relevantIndices.join(', ')}]`);

        const filtered = relevantIndices
          .filter((idx) => idx >= 0 && idx < searchResults.length)
          .map((idx) => searchResults[idx]);

        // Return filtered results, or all if filtering failed
        if (filtered.length > 0) {
          console.log(
            `Pre-filtering successful: ${filtered.length}/${searchResults.length} results retained`,
          );
          return filtered;
        }
      }
    } catch (error) {
      console.warn('Pre-filtering failed, using all results:', error.message);
    }

    // Fallback: return all results if filtering fails
    console.log('Using all results (no filtering applied)');
    return searchResults;
  }

  private buildFormattingPrompt(
    userQuery: string,
    searchResults: any[],
  ): string {
    // Prepare search results for the prompt
    const resultsText = searchResults
      .map((result, index) => {
        const metadata = result.fields?.metadata || {};
        const text = result.fields?.text || '';
        const score = result._score || 0;

        return `[Source ${index + 1}] (Relevance: ${(score * 100).toFixed(1)}%)
Document: ${metadata.fileName || 'Unknown'}
Content: ${text}
---`;
      })
      .join('\n\n');

    return `You are a helpful AI assistant that formats search results into a user-friendly answer.

CRITICAL REQUIREMENTS:
1. Answer the user's question ONLY based on the provided search results
2. DO NOT add any information from your training data or the internet
3. DO NOT make up or hallucinate any information
4. Use clear citations like [Source 1], [Source 2] when referencing information
5. If the search results don't contain enough information to answer the question, say so clearly
6. Format your answer in a clear, structured way with proper paragraphs
7. Use the exact information from the sources without rephrasing unless necessary for clarity
8. FILTER OUT irrelevant information from the search results that doesn't relate to the user's question
9. Focus ONLY on the parts of the search results that directly answer the user's question
10. Ignore any content in the search results that is off-topic or unrelated to the question

USER QUESTION:
${userQuery}

SEARCH RESULTS:
${resultsText}

TASK:
1. Read the user's question carefully
2. Review all search results
3. FILTER and select ONLY the information that directly answers the question
4. Ignore any irrelevant or unrelated content from the search results
5. Provide a clear, well-formatted answer using ONLY the relevant filtered information
6. Include citations [Source N] for each piece of information you use

Please provide your filtered and formatted answer now:`;
  }

  async generateChatTitle(firstMessage: string): Promise<string> {
    try {
      const prompt = this.buildTitlePrompt(firstMessage);

      const response = await this.genAI.models.generateContent({
        model: 'gemini-2.5-flash',
        contents: prompt,
      });

      const title = response.text.trim();
      
      // Ensure title is not too long (max 50 characters)
      return title.length > 50 ? title.substring(0, 47) + '...' : title;
    } catch (error) {
      console.error('Error generating chat title with Gemini:', error);
      // Fallback to a simple title
      return this.generateFallbackTitle(firstMessage);
    }
  }

  private buildTitlePrompt(firstMessage: string): string {
    return `You are a helpful assistant that creates short, clear chat titles based on user messages.

TASK: Create a concise, descriptive title for a chat conversation based on the first user message.

REQUIREMENTS:
1. Title should be 2-8 words maximum
2. Title should clearly describe the main topic or question
3. Use simple, clear language
4. Avoid technical jargon unless necessary
5. Make it user-friendly and searchable
6. Do NOT include question marks, exclamation marks, or special characters
7. Use title case (capitalize first letter of each word)

EXAMPLES:
- "как оформить электронную подпись?" → "Оформление Электронной Подписи"
- "расскажи про отпуск и больничные" → "Отпуск И Больничные"
- "как работает система HR?" → "Работа HR Системы"
- "помоги с настройкой компьютера" → "Настройка Компьютера"

USER MESSAGE: ${firstMessage}

CHAT TITLE:`;
  }

  private generateFallbackTitle(firstMessage: string): string {
    // Simple fallback: take first few words and capitalize
    const words = firstMessage
      .split(' ')
      .slice(0, 4)
      .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
      .join(' ');
    
    return words || 'Новый Чат';
  }

  async testConnection(): Promise<boolean> {
    try {
      const response = await this.genAI.models.generateContent({
        model: 'gemini-2.5-flash',
        contents: 'Hello',
      });

      return !!response.text;
    } catch (error) {
      console.error('Gemini connection test failed:', error);
      return false;
    }
  }
}

